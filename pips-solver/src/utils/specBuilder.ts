/**
 * Converts OverlayBuilderState to PuzzleSpec
 * Used to save puzzles created via the OverlayBuilder wizard
 */

import {
  OverlayBuilderState,
  ConstraintDef,
  DominoPair,
} from '../model/overlayTypes';
import {
  PuzzleSpec,
  RegionConstraint,
  ConstraintOp as SpecConstraintOp,
} from '../model/types';

// ════════════════════════════════════════════════════════════════════════════
// Main Conversion Function
// ════════════════════════════════════════════════════════════════════════════

export interface SpecBuilderResult {
  success: boolean;
  spec?: PuzzleSpec;
  yaml?: string;
  errors: string[];
  warnings: string[];
}

/**
 * Convert OverlayBuilderState to PuzzleSpec
 */
export function buildPuzzleSpec(
  state: OverlayBuilderState,
  name?: string
): SpecBuilderResult {
  const errors: string[] = [];
  const warnings: string[] = [];

  const { grid, regions, constraints, dominoes } = state;

  // Validate we have a valid grid
  if (grid.rows < 1 || grid.cols < 1) {
    errors.push('Grid must have at least 1 row and 1 column');
    return { success: false, errors, warnings };
  }

  // Build regions matrix (convert null to -1 for holes)
  const regionsMatrix: number[][] = [];
  for (let r = 0; r < grid.rows; r++) {
    const row: number[] = [];
    for (let c = 0; c < grid.cols; c++) {
      const isHole = grid.holes[r]?.[c] ?? false;
      const regionIndex = regions.regionGrid[r]?.[c];

      if (isHole) {
        row.push(-1); // -1 indicates hole/no cell
      } else if (regionIndex === null || regionIndex === undefined) {
        row.push(0); // Default to region 0 if not painted
        warnings.push(`Cell (${r},${c}) has no region assigned, defaulting to region 0`);
      } else {
        row.push(regionIndex);
      }
    }
    regionsMatrix.push(row);
  }

  // Count valid cells
  let cellCount = 0;
  regionsMatrix.forEach(row =>
    row.forEach(cell => {
      if (cell !== -1) cellCount++;
    })
  );

  // Validate domino count
  const expectedDominoes = Math.floor(cellCount / 2);
  if (dominoes.dominoes.length !== expectedDominoes) {
    warnings.push(
      `Expected ${expectedDominoes} dominoes for ${cellCount} cells, got ${dominoes.dominoes.length}`
    );
  }

  // Find which regions are actually used
  const usedRegions = new Set<number>();
  regionsMatrix.forEach(row =>
    row.forEach(regionId => {
      if (regionId !== -1) usedRegions.add(regionId);
    })
  );

  // Build constraints object
  const specConstraints: { [regionId: number]: RegionConstraint } = {};
  usedRegions.forEach(regionId => {
    const constraintDef = constraints.regionConstraints[regionId];
    if (constraintDef && constraintDef.type !== 'none') {
      specConstraints[regionId] = convertConstraint(constraintDef);
    }
  });

  // Build the PuzzleSpec
  const spec: PuzzleSpec = {
    id: `puzzle_${Date.now()}`,
    name: name || `Puzzle ${new Date().toLocaleDateString()}`,
    rows: grid.rows,
    cols: grid.cols,
    maxPip: 6,
    allowDuplicates: false,
    regions: regionsMatrix,
    constraints: specConstraints,
    dominoes: dominoes.dominoes,
  };

  // Generate YAML
  const yaml = generateYaml(spec, dominoes.dominoes, regions.palette.labels);

  return {
    success: errors.length === 0,
    spec,
    yaml,
    errors,
    warnings,
  };
}

// ════════════════════════════════════════════════════════════════════════════
// Helper Functions
// ════════════════════════════════════════════════════════════════════════════

/**
 * Convert OverlayBuilder constraint to PuzzleSpec constraint
 */
function convertConstraint(def: ConstraintDef): RegionConstraint {
  switch (def.type) {
    case 'sum':
      // For NYT Pips, operators apply to the REGION SUM.
      // Represent equals as `sum`, and comparisons as `op/value`.
      if (!def.op || def.op === '==') {
        return { sum: def.value };
      }
      return { op: convertOp(def.op), value: def.value };
    case 'all_equal':
      return { all_equal: true };
    case 'all_different':
      return { all_different: true };
    default:
      return {};
  }
}

/**
 * Convert operator format
 */
function convertOp(op?: string): SpecConstraintOp | undefined {
  switch (op) {
    case '==':
      return '=';
    case '<':
      return '<';
    case '>':
      return '>';
    case '!=':
      return '≠';
    default:
      return undefined;
  }
}

/**
 * Generate YAML string from PuzzleSpec
 */
function generateYaml(
  spec: PuzzleSpec,
  dominoes: DominoPair[],
  regionLabels: string[]
): string {
  const lines: string[] = [];

  lines.push(`# ${spec.name}`);
  lines.push(`# Generated by OverlayBuilder`);
  lines.push('');
  lines.push('pips:');
  lines.push(`  pip_min: 0`);
  lines.push(`  pip_max: ${spec.maxPip || 6}`);
  lines.push('');

  // Dominoes
  lines.push('dominoes:');
  lines.push(`  unique: ${!spec.allowDuplicates}`);
  lines.push('  tiles:');
  dominoes.forEach(([pip1, pip2]) => {
    lines.push(`    - [${pip1}, ${pip2}]`);
  });
  lines.push('');

  // Board shape
  lines.push('board:');
  lines.push('  shape: |');
  spec.regions.forEach(row => {
    const shapeRow = row.map(cell => (cell === -1 ? '#' : '.')).join('');
    lines.push(`    ${shapeRow}`);
  });
  lines.push('');

  // Board regions
  lines.push('  regions: |');
  spec.regions.forEach(row => {
    const regionRow = row
      .map(cell => (cell === -1 ? '#' : regionLabels[cell] || String.fromCharCode(65 + cell)))
      .join('');
    lines.push(`    ${regionRow}`);
  });
  lines.push('');

  // Region constraints
  const constraintEntries = Object.entries(spec.constraints);
  if (constraintEntries.length > 0) {
    lines.push('region_constraints:');
    constraintEntries.forEach(([regionId, constraint]) => {
      const label = regionLabels[parseInt(regionId, 10)] || String.fromCharCode(65 + parseInt(regionId, 10));

      if (constraint.all_equal) {
        lines.push(`  ${label}: { type: all_equal }`);
      } else if (constraint.sum !== undefined) {
        const opStr = constraint.op || '=';
        const opYaml = opStr === '=' ? '"=="' : opStr === '≠' ? '"!="' : `"${opStr}"`;
        lines.push(`  ${label}: { type: sum, op: ${opYaml}, value: ${constraint.value} }`);
      }
    });
  }

  return lines.join('\n');
}

// ════════════════════════════════════════════════════════════════════════════
// Validation Utilities
// ════════════════════════════════════════════════════════════════════════════

/**
 * Validate the OverlayBuilderState before building spec
 */
export function validateBuilderState(state: OverlayBuilderState): {
  valid: boolean;
  errors: string[];
  warnings: string[];
} {
  const errors: string[] = [];
  const warnings: string[] = [];

  const { grid, regions, dominoes } = state;

  // Check grid
  if (grid.rows < 1 || grid.cols < 1) {
    errors.push('Grid must have at least 1 row and 1 column');
  }

  // Count valid cells
  let cellCount = 0;
  for (let r = 0; r < grid.rows; r++) {
    for (let c = 0; c < grid.cols; c++) {
      if (!grid.holes[r]?.[c]) {
        cellCount++;
      }
    }
  }

  // Check even cell count
  if (cellCount % 2 !== 0) {
    errors.push(`Cell count (${cellCount}) must be even for dominoes`);
  }

  // Check domino count
  const expectedDominoes = Math.floor(cellCount / 2);
  if (dominoes.dominoes.length !== expectedDominoes) {
    if (dominoes.dominoes.length === 0) {
      errors.push(`No dominoes entered. Need ${expectedDominoes} dominoes for ${cellCount} cells`);
    } else {
      warnings.push(
        `Expected ${expectedDominoes} dominoes for ${cellCount} cells, got ${dominoes.dominoes.length}`
      );
    }
  }

  // Check all cells have regions
  const unpaintedCells: string[] = [];
  for (let r = 0; r < grid.rows; r++) {
    for (let c = 0; c < grid.cols; c++) {
      if (!grid.holes[r]?.[c]) {
        const regionIndex = regions.regionGrid[r]?.[c];
        if (regionIndex === null || regionIndex === undefined) {
          unpaintedCells.push(`(${r},${c})`);
        }
      }
    }
  }
  if (unpaintedCells.length > 0) {
    warnings.push(`Cells without regions: ${unpaintedCells.join(', ')}`);
  }

  return {
    valid: errors.length === 0,
    errors,
    warnings,
  };
}

/**
 * Get summary stats for the builder state
 */
export function getBuilderStats(state: OverlayBuilderState): {
  cellCount: number;
  regionCount: number;
  dominoCount: number;
  constraintCount: number;
  holeCount: number;
} {
  const { grid, regions, constraints, dominoes } = state;

  let cellCount = 0;
  let holeCount = 0;
  const usedRegions = new Set<number>();

  for (let r = 0; r < grid.rows; r++) {
    for (let c = 0; c < grid.cols; c++) {
      if (grid.holes[r]?.[c]) {
        holeCount++;
      } else {
        cellCount++;
        const regionIndex = regions.regionGrid[r]?.[c];
        if (regionIndex !== null && regionIndex !== undefined) {
          usedRegions.add(regionIndex);
        }
      }
    }
  }

  const constraintCount = Object.values(constraints.regionConstraints).filter(
    c => c.type !== 'none'
  ).length;

  return {
    cellCount,
    regionCount: usedRegions.size,
    dominoCount: dominoes.dominoes.length,
    constraintCount,
    holeCount,
  };
}
