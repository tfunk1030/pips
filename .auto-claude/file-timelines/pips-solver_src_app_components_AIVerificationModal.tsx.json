{
  "file_path": "pips-solver/src/app/components/AIVerificationModal.tsx",
  "main_branch_history": [],
  "task_views": {
    "005-add-image-stats-diagnostic-endpoint": {
      "task_id": "005-add-image-stats-diagnostic-endpoint",
      "branch_point": {
        "commit_hash": "faf3f69f9b2794c6a85ffd2581461d3d68bdf8ef",
        "content": "",
        "timestamp": "2025-12-22T03:09:16.372053"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "005-add-image-stats-diagnostic-endpoint",
        "description": "Create a _calculate_image_stats function and expose it as a standalone API endpoint that returns brightness, contrast, dynamic range, color balance, and saturation metrics without requiring preprocessing. This helps users diagnose image quality issues before extraction.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    },
    "009-ai-verification-modal-lacks-keyboard-accessibility": {
      "task_id": "009-ai-verification-modal-lacks-keyboard-accessibility",
      "branch_point": {
        "commit_hash": "49d2f4bb87113251aef5fa1197098718f3701e89",
        "content": "/**\n * AI Verification Modal\n * Shows what the AI extracted before applying it to the builder state\n * Enhanced with visual diff showing extraction vs image overlay\n * Includes cell-by-cell correction UI for manual fixes\n */\n\nimport React, { useCallback, useMemo, useState } from 'react';\nimport {\n  Alert,\n  Image,\n  Modal,\n  ScrollView,\n  StyleSheet,\n  Text,\n  TextInput,\n  TouchableOpacity,\n  View,\n  useWindowDimensions,\n} from 'react-native';\nimport Svg, { Circle, G, Line, Rect, Text as SvgText } from 'react-native-svg';\nimport {\n  BoardExtractionResult,\n  DominoExtractionResult,\n  DominoPair,\n  ImageInfo,\n} from '../../model/overlayTypes';\nimport { colors, radii, spacing } from '../../theme';\n\n// View modes for the modal\ntype ViewMode = 'text' | 'visual';\n\n// Dimension constraints for grid editing\nconst MIN_DIMENSION = 3;\nconst MAX_DIMENSION = 20;\n\n// Edit target type for tracking what's being edited\ntype EditTarget =\n  | { type: 'cell'; row: number; col: number }\n  | { type: 'domino'; index: number; half: 0 | 1 }\n  | { type: 'constraint'; regionLabel: string }\n  | { type: 'dimensions' }\n  | null;\n\n// Editable results that can be modified by the user\ninterface EditableBoardResult extends BoardExtractionResult {\n  // We keep the same structure but allow modifications\n}\n\ninterface EditableDominoResult extends DominoExtractionResult {\n  // We keep the same structure but allow modifications\n}\n\ninterface Props {\n  visible: boolean;\n  boardResult: BoardExtractionResult;\n  dominoResult: DominoExtractionResult;\n  onAccept: (editedBoard?: BoardExtractionResult, editedDominoes?: DominoExtractionResult) => void;\n  onReject: () => void;\n  /** Optional source image to show overlay comparison */\n  sourceImage?: ImageInfo | null;\n}\n\n// Region color palette for visual diff (matches theme/tokens.ts)\nconst REGION_COLORS = [\n  '#4A6670', // Teal Shadow\n  '#8B6B5C', // Warm Stone\n  '#5C4A6E', // Dusty Violet\n  '#6B7A4A', // Olive Drab\n  '#6E5A4A', // Umber\n  '#4A5C6E', // Steel Blue\n  '#6E4A5C', // Mauve\n  '#5C6E4A', // Sage\n  '#7A5C4A', // Sienna\n  '#4A6E5C', // Sea Green\n];\n\n// Parse regions string to 2D array with letter-to-index mapping\nfunction parseRegionsToGrid(regionsStr: string): { grid: (number | null)[][]; labels: string[] } {\n  const lines = regionsStr.split('\\\\n').filter(line => line.length > 0);\n  const labels: string[] = [];\n  const labelToIndex: Record<string, number> = {};\n\n  const grid = lines.map(line =>\n    line.split('').map(char => {\n      if (char === '#' || char === '.') return null;\n      if (!(char in labelToIndex)) {\n        labelToIndex[char] = labels.length;\n        labels.push(char);\n      }\n      return labelToIndex[char];\n    })\n  );\n\n  return { grid, labels };\n}\n\n// Parse shape string to 2D boolean array (true = hole)\nfunction parseShapeToHoles(shapeStr: string): boolean[][] {\n  const lines = shapeStr.split('\\\\n').filter(line => line.length > 0);\n  return lines.map(line =>\n    line.split('').map(char => char === '#')\n  );\n}\n\nexport default function AIVerificationModal({\n  visible,\n  boardResult,\n  dominoResult,\n  onAccept,\n  onReject,\n  sourceImage,\n}: Props) {\n  const { width: screenWidth } = useWindowDimensions();\n  const [viewMode, setViewMode] = useState<ViewMode>('visual');\n  const [showOverlay, setShowOverlay] = useState(true);\n\n  // Editing state - track editable copies of the results\n  const [editedBoard, setEditedBoard] = useState<EditableBoardResult>(() => ({\n    ...boardResult,\n  }));\n  const [editedDominoes, setEditedDominoes] = useState<EditableDominoResult>(() => ({\n    ...dominoResult,\n  }));\n  const [editTarget, setEditTarget] = useState<EditTarget>(null);\n  const [hasEdits, setHasEdits] = useState(false);\n\n  // Reset edited state when props change\n  React.useEffect(() => {\n    setEditedBoard({ ...boardResult });\n    setEditedDominoes({ ...dominoResult });\n    setHasEdits(false);\n    setEditTarget(null);\n  }, [boardResult, dominoResult]);\n\n  // Parse extraction data for visual rendering (use edited versions)\n  const parsedData = useMemo(() => {\n    const holes = parseShapeToHoles(editedBoard.shape);\n    const { grid: regionGrid, labels: regionLabels } = parseRegionsToGrid(editedBoard.regions);\n    return { holes, regionGrid, regionLabels };\n  }, [editedBoard.shape, editedBoard.regions]);\n\n  // Calculate grid dimensions for SVG\n  const gridLayout = useMemo(() => {\n    const padding = 16;\n    const maxWidth = screenWidth - 40; // Account for modal padding\n    const cellSize = Math.min(40, Math.floor((maxWidth - padding * 2) / editedBoard.cols));\n    const gridWidth = editedBoard.cols * cellSize + padding * 2;\n    const gridHeight = editedBoard.rows * cellSize + padding * 2;\n    return { cellSize, gridWidth, gridHeight, padding };\n  }, [editedBoard.rows, editedBoard.cols, screenWidth]);\n\n  // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n  // Editing Callbacks\n  // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n  /**\n   * Handle cell selection for editing\n   */\n  const handleCellPress = useCallback((row: number, col: number) => {\n    setEditTarget({ type: 'cell', row, col });\n  }, []);\n\n  /**\n   * Toggle a cell between hole and active cell\n   */\n  const toggleCellHole = useCallback((row: number, col: number) => {\n    setEditedBoard(prev => {\n      const shapeLines = prev.shape.split('\\\\n');\n      const regionLines = prev.regions.split('\\\\n');\n\n      // Get current character at position\n      const currentShapeChar = shapeLines[row]?.[col];\n      const isCurrentlyHole = currentShapeChar === '#';\n\n      // Update shape string\n      const newShapeLines = shapeLines.map((line, r) => {\n        if (r !== row) return line;\n        const chars = line.split('');\n        chars[col] = isCurrentlyHole ? 'O' : '#';\n        return chars.join('');\n      });\n\n      // Update regions string\n      const newRegionLines = regionLines.map((line, r) => {\n        if (r !== row) return line;\n        const chars = line.split('');\n        if (isCurrentlyHole) {\n          // Converting from hole to cell - assign to first region\n          chars[col] = 'A';\n        } else {\n          // Converting from cell to hole\n          chars[col] = '#';\n        }\n        return chars.join('');\n      });\n\n      return {\n        ...prev,\n        shape: newShapeLines.join('\\\\n'),\n        regions: newRegionLines.join('\\\\n'),\n      };\n    });\n    setHasEdits(true);\n    setEditTarget(null);\n  }, []);\n\n  /**\n   * Change the region assignment for a cell\n   */\n  const changeCellRegion = useCallback((row: number, col: number, newRegionLabel: string) => {\n    setEditedBoard(prev => {\n      const regionLines = prev.regions.split('\\\\n');\n\n      const newRegionLines = regionLines.map((line, r) => {\n        if (r !== row) return line;\n        const chars = line.split('');\n        if (chars[col] !== '#') {\n          chars[col] = newRegionLabel;\n        }\n        return chars.join('');\n      });\n\n      return {\n        ...prev,\n        regions: newRegionLines.join('\\\\n'),\n      };\n    });\n    setHasEdits(true);\n    setEditTarget(null);\n  }, []);\n\n  /**\n   * Handle domino pip value editing\n   */\n  const handleDominoPipChange = useCallback((index: number, half: 0 | 1, newValue: number) => {\n    if (newValue < 0 || newValue > 6) return;\n\n    setEditedDominoes(prev => {\n      const newDominoes = [...prev.dominoes];\n      const domino = [...newDominoes[index]] as DominoPair;\n      domino[half] = newValue;\n      newDominoes[index] = domino;\n      return { ...prev, dominoes: newDominoes };\n    });\n    setHasEdits(true);\n    setEditTarget(null);\n  }, []);\n\n  /**\n   * Increment/decrement a domino pip value\n   */\n  const cycleDominoPip = useCallback((index: number, half: 0 | 1, direction: 1 | -1) => {\n    setEditedDominoes(prev => {\n      const newDominoes = [...prev.dominoes];\n      const domino = [...newDominoes[index]] as DominoPair;\n      let newVal = domino[half] + direction;\n      if (newVal < 0) newVal = 6;\n      if (newVal > 6) newVal = 0;\n      domino[half] = newVal;\n      newDominoes[index] = domino;\n      return { ...prev, dominoes: newDominoes };\n    });\n    setHasEdits(true);\n  }, []);\n\n  /**\n   * Handle constraint value editing\n   */\n  const handleConstraintChange = useCallback(\n    (regionLabel: string, type: string, value?: number, op?: string) => {\n      setEditedBoard(prev => {\n        const newConstraints = { ...prev.constraints };\n        newConstraints[regionLabel] = { type, value, op };\n        return { ...prev, constraints: newConstraints };\n      });\n      setHasEdits(true);\n      setEditTarget(null);\n    },\n    []\n  );\n\n  /**\n   * Delete a constraint\n   */\n  const deleteConstraint = useCallback((regionLabel: string) => {\n    setEditedBoard(prev => {\n      const newConstraints = { ...prev.constraints };\n      delete newConstraints[regionLabel];\n      return { ...prev, constraints: newConstraints };\n    });\n    setHasEdits(true);\n    setEditTarget(null);\n  }, []);\n\n  // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n  // Dimension Change Handlers\n  // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n  /**\n   * Handle row count change with validation and orphan cell check\n   */\n  const handleRowChange = useCallback((delta: number) => {\n    const newRows = editedBoard.rows + delta;\n\n    // Validate bounds\n    if (newRows < MIN_DIMENSION || newRows > MAX_DIMENSION) {\n      return;\n    }\n\n    // Check for orphaned cells when shrinking\n    if (delta < 0 && wouldOrphanCells(\n      editedBoard.shape,\n      editedBoard.rows,\n      editedBoard.cols,\n      newRows,\n      editedBoard.cols\n    )) {\n      Alert.alert(\n        'Remove Active Cells?',\n        'Reducing rows will remove cells that are part of the puzzle. Continue?',\n        [\n          { text: 'Cancel', style: 'cancel' },\n          {\n            text: 'Remove',\n            style: 'destructive',\n            onPress: () => applyRowChange(newRows),\n          },\n        ]\n      );\n      return;\n    }\n\n    applyRowChange(newRows);\n  }, [editedBoard]);\n\n  /**\n   * Apply the row change after validation/confirmation\n   */\n  const applyRowChange = useCallback((newRows: number) => {\n    setEditedBoard(prev => {\n      const newShape = resizeShapeString(\n        prev.shape,\n        prev.rows,\n        prev.cols,\n        newRows,\n        prev.cols\n      );\n      const newRegions = resizeRegionsString(\n        prev.regions,\n        prev.rows,\n        prev.cols,\n        newRows,\n        prev.cols\n      );\n\n      return {\n        ...prev,\n        rows: newRows,\n        shape: newShape,\n        regions: newRegions,\n      };\n    });\n    setHasEdits(true);\n  }, []);\n\n  /**\n   * Handle column count change with validation and orphan cell check\n   */\n  const handleColChange = useCallback((delta: number) => {\n    const newCols = editedBoard.cols + delta;\n\n    // Validate bounds\n    if (newCols < MIN_DIMENSION || newCols > MAX_DIMENSION) {\n      return;\n    }\n\n    // Check for orphaned cells when shrinking\n    if (delta < 0 && wouldOrphanCells(\n      editedBoard.shape,\n      editedBoard.rows,\n      editedBoard.cols,\n      editedBoard.rows,\n      newCols\n    )) {\n      Alert.alert(\n        'Remove Active Cells?',\n        'Reducing columns will remove cells that are part of the puzzle. Continue?',\n        [\n          { text: 'Cancel', style: 'cancel' },\n          {\n            text: 'Remove',\n            style: 'destructive',\n            onPress: () => applyColChange(newCols),\n          },\n        ]\n      );\n      return;\n    }\n\n    applyColChange(newCols);\n  }, [editedBoard]);\n\n  /**\n   * Apply the column change after validation/confirmation\n   */\n  const applyColChange = useCallback((newCols: number) => {\n    setEditedBoard(prev => {\n      const newShape = resizeShapeString(\n        prev.shape,\n        prev.rows,\n        prev.cols,\n        prev.rows,\n        newCols\n      );\n      const newRegions = resizeRegionsString(\n        prev.regions,\n        prev.rows,\n        prev.cols,\n        prev.rows,\n        newCols\n      );\n\n      return {\n        ...prev,\n        cols: newCols,\n        shape: newShape,\n        regions: newRegions,\n      };\n    });\n    setHasEdits(true);\n  }, []);\n\n  /**\n   * Handle accept with edited values\n   */\n  const handleAccept = useCallback(() => {\n    if (hasEdits) {\n      onAccept(editedBoard, editedDominoes);\n    } else {\n      onAccept();\n    }\n  }, [hasEdits, editedBoard, editedDominoes, onAccept]);\n\n  /**\n   * Reset all edits to original values\n   */\n  const resetEdits = useCallback(() => {\n    setEditedBoard({ ...boardResult });\n    setEditedDominoes({ ...dominoResult });\n    setHasEdits(false);\n    setEditTarget(null);\n  }, [boardResult, dominoResult]);\n\n  // Format shape and regions for text display\n  const formatGrid = (str: string) => {\n    return str.split('\\\\n').map((line, i) => (\n      <Text key={i} style={styles.gridLine}>\n        {line.split('').map((char, j) => (\n          <Text\n            key={j}\n            style={[\n              styles.gridChar,\n              char === '#' && styles.holeChar,\n              char === '.' && styles.emptyChar,\n            ]}\n          >\n            {char === '.' ? '\u00b7' : char}\n          </Text>\n        ))}\n      </Text>\n    ));\n  };\n\n  // Render visual grid with regions and holes (editable version)\n  const renderVisualGrid = () => {\n    const { cellSize, gridWidth, gridHeight, padding } = gridLayout;\n    const { holes, regionGrid, regionLabels } = parsedData;\n    const elements: React.ReactElement[] = [];\n\n    // Check if a cell is currently selected\n    const isSelectedCell = (row: number, col: number) =>\n      editTarget?.type === 'cell' && editTarget.row === row && editTarget.col === col;\n\n    // Draw cells with region colors\n    for (let row = 0; row < editedBoard.rows; row++) {\n      for (let col = 0; col < editedBoard.cols; col++) {\n        const x = padding + col * cellSize;\n        const y = padding + row * cellSize;\n        const isHole = holes[row]?.[col] ?? false;\n        const regionIndex = regionGrid[row]?.[col];\n        const isSelected = isSelectedCell(row, col);\n\n        if (isHole) {\n          // Render hole as dark void\n          elements.push(\n            <Rect\n              key={`hole-${row}-${col}`}\n              x={x + 2}\n              y={y + 2}\n              width={cellSize - 4}\n              height={cellSize - 4}\n              fill={colors.surface.obsidian}\n              rx={radii.sm}\n              opacity={0.9}\n              stroke={isSelected ? colors.accent.brass : undefined}\n              strokeWidth={isSelected ? 2 : 0}\n            />\n          );\n        } else {\n          // Render cell with region color\n          const regionColor = regionIndex !== null\n            ? REGION_COLORS[regionIndex % REGION_COLORS.length]\n            : colors.surface.slate;\n\n          elements.push(\n            <Rect\n              key={`cell-${row}-${col}`}\n              x={x + 1}\n              y={y + 1}\n              width={cellSize - 2}\n              height={cellSize - 2}\n              fill={regionColor}\n              rx={radii.sm}\n              opacity={0.85}\n              stroke={isSelected ? colors.accent.brass : undefined}\n              strokeWidth={isSelected ? 3 : 0}\n            />\n          );\n\n          // Add region label in cell center\n          if (regionIndex !== null && regionLabels[regionIndex]) {\n            elements.push(\n              <SvgText\n                key={`label-${row}-${col}`}\n                x={x + cellSize / 2}\n                y={y + cellSize / 2 + 4}\n                fontSize={cellSize * 0.4}\n                fontWeight=\"600\"\n                fill={colors.text.primary}\n                textAnchor=\"middle\"\n                opacity={0.7}\n              >\n                {regionLabels[regionIndex]}\n              </SvgText>\n            );\n          }\n        }\n      }\n    }\n\n    // Draw grid lines\n    for (let row = 0; row <= editedBoard.rows; row++) {\n      const y = padding + row * cellSize;\n      elements.push(\n        <Line\n          key={`h-line-${row}`}\n          x1={padding}\n          y1={y}\n          x2={padding + editedBoard.cols * cellSize}\n          y2={y}\n          stroke={colors.surface.ash}\n          strokeWidth={1}\n          opacity={0.4}\n        />\n      );\n    }\n    for (let col = 0; col <= editedBoard.cols; col++) {\n      const x = padding + col * cellSize;\n      elements.push(\n        <Line\n          key={`v-line-${col}`}\n          x1={x}\n          y1={padding}\n          x2={x}\n          y2={padding + editedBoard.rows * cellSize}\n          stroke={colors.surface.ash}\n          strokeWidth={1}\n          opacity={0.4}\n        />\n      );\n    }\n\n    // Add constraint indicators (small circles at region centers)\n    const regionCenters = calculateRegionCenters(regionGrid, editedBoard.constraints);\n    regionCenters.forEach((center, idx) => {\n      if (center.constraint) {\n        const cx = padding + center.col * cellSize + cellSize / 2;\n        const cy = padding + center.row * cellSize + cellSize / 2;\n\n        // Diamond shape for constraints (rotated square)\n        const size = cellSize * 0.35;\n        elements.push(\n          <G key={`constraint-${idx}`}>\n            <Rect\n              x={cx - size / 2}\n              y={cy - size / 2}\n              width={size}\n              height={size}\n              fill={colors.accent.brass}\n              transform={`rotate(45, ${cx}, ${cy})`}\n              opacity={0.9}\n            />\n            <SvgText\n              x={cx}\n              y={cy + 3}\n              fontSize={size * 0.6}\n              fontWeight=\"700\"\n              fill={colors.text.inverse}\n              textAnchor=\"middle\"\n            >\n              {center.constraint.value ?? '='}\n            </SvgText>\n          </G>\n        );\n      }\n    });\n\n    return (\n      <View style={styles.visualGridContainer}>\n        <Svg width={gridWidth} height={gridHeight}>\n          <Rect\n            x={0}\n            y={0}\n            width={gridWidth}\n            height={gridHeight}\n            fill={colors.surface.charcoal}\n            rx={radii.lg}\n          />\n          <G>{elements}</G>\n        </Svg>\n        {/* Touch overlay for cell selection */}\n        <View style={[styles.cellTouchOverlay, { width: gridWidth, height: gridHeight }]}>\n          {Array.from({ length: editedBoard.rows }).map((_, row) =>\n            Array.from({ length: editedBoard.cols }).map((_, col) => (\n              <TouchableOpacity\n                key={`touch-${row}-${col}`}\n                style={[\n                  styles.cellTouchTarget,\n                  {\n                    left: padding + col * cellSize,\n                    top: padding + row * cellSize,\n                    width: cellSize,\n                    height: cellSize,\n                  },\n                ]}\n                onPress={() => handleCellPress(row, col)}\n                activeOpacity={0.7}\n              />\n            ))\n          )}\n        </View>\n      </View>\n    );\n  };\n\n  // Render dominoes visually (editable version)\n  const renderVisualDominoes = () => {\n    return (\n      <View style={styles.visualDominoContainer}>\n        <Text style={styles.editHint}>Tap halves to cycle pip values (0-6)</Text>\n        {editedDominoes.dominoes.map((domino, i) => (\n          <View key={i} style={styles.visualDomino}>\n            <TouchableOpacity\n              style={styles.dominoHalfTouchable}\n              onPress={() => cycleDominoPip(i, 0, 1)}\n              onLongPress={() => cycleDominoPip(i, 0, -1)}\n              delayLongPress={300}\n            >\n              <View style={styles.dominoHalf}>{renderPips(domino[0])}</View>\n            </TouchableOpacity>\n            <View style={styles.dominoDivider} />\n            <TouchableOpacity\n              style={styles.dominoHalfTouchable}\n              onPress={() => cycleDominoPip(i, 1, 1)}\n              onLongPress={() => cycleDominoPip(i, 1, -1)}\n              delayLongPress={300}\n            >\n              <View style={styles.dominoHalf}>{renderPips(domino[1])}</View>\n            </TouchableOpacity>\n            <Text style={styles.dominoIndex}>#{i + 1}</Text>\n          </View>\n        ))}\n      </View>\n    );\n  };\n\n  // Render pip dots for a domino half\n  const renderPips = (value: number) => {\n    const pipPositions = getPipPositions(value);\n    return (\n      <View style={styles.pipContainer}>\n        {pipPositions.map((pos, i) => (\n          <View\n            key={i}\n            style={[\n              styles.pip,\n              { left: `${50 + pos.x * 35}%`, top: `${50 + pos.y * 35}%` },\n            ]}\n          />\n        ))}\n      </View>\n    );\n  };\n\n  return (\n    <Modal visible={visible} animationType=\"slide\" presentationStyle=\"pageSheet\">\n      <View style={styles.container}>\n        <View style={styles.header}>\n          <View style={styles.headerRow}>\n            <View>\n              <Text style={styles.title}>Verify AI Extraction</Text>\n              <Text style={styles.subtitle}>\n                {hasEdits ? 'Tap cells to edit \u2022 Review changes below' : 'Tap cells to correct errors'}\n              </Text>\n            </View>\n            {hasEdits && (\n              <TouchableOpacity style={styles.resetButton} onPress={resetEdits}>\n                <Text style={styles.resetButtonText}>Reset</Text>\n              </TouchableOpacity>\n            )}\n          </View>\n\n          {/* Edit indicator badge */}\n          {hasEdits && (\n            <View style={styles.editBadge}>\n              <Text style={styles.editBadgeText}>Modified</Text>\n            </View>\n          )}\n\n          {/* View mode toggle */}\n          <View style={styles.viewToggle}>\n            <TouchableOpacity\n              style={[styles.toggleButton, viewMode === 'visual' && styles.toggleButtonActive]}\n              onPress={() => setViewMode('visual')}\n            >\n              <Text style={[styles.toggleText, viewMode === 'visual' && styles.toggleTextActive]}>\n                Visual\n              </Text>\n            </TouchableOpacity>\n            <TouchableOpacity\n              style={[styles.toggleButton, viewMode === 'text' && styles.toggleButtonActive]}\n              onPress={() => setViewMode('text')}\n            >\n              <Text style={[styles.toggleText, viewMode === 'text' && styles.toggleTextActive]}>\n                Text\n              </Text>\n            </TouchableOpacity>\n          </View>\n        </View>\n\n        <ScrollView style={styles.content} contentContainerStyle={styles.contentContainer}>\n          {viewMode === 'visual' ? (\n            <>\n              {/* Visual Grid Preview with Image Overlay */}\n              <View style={styles.section}>\n                <View style={styles.sectionHeader}>\n                  <Text style={styles.sectionTitle}>\n                    Grid ({editedBoard.rows}\u00d7{editedBoard.cols})\n                  </Text>\n                  {sourceImage && (\n                    <TouchableOpacity\n                      style={styles.overlayToggle}\n                      onPress={() => setShowOverlay(!showOverlay)}\n                    >\n                      <Text style={styles.overlayToggleText}>\n                        {showOverlay ? 'Hide Overlay' : 'Show Overlay'}\n                      </Text>\n                    </TouchableOpacity>\n                  )}\n                </View>\n\n                <Text style={styles.editHint}>Tap a cell to edit region or toggle hole</Text>\n\n                {/* Source image with overlay comparison */}\n                {sourceImage && showOverlay ? (\n                  <View style={styles.imageOverlayContainer}>\n                    <Image\n                      source={{ uri: sourceImage.uri }}\n                      style={[\n                        styles.sourceImage,\n                        {\n                          width: gridLayout.gridWidth,\n                          height: gridLayout.gridHeight,\n                        },\n                      ]}\n                      resizeMode=\"contain\"\n                    />\n                    <View style={styles.overlayGrid}>\n                      {renderVisualGrid()}\n                    </View>\n                  </View>\n                ) : (\n                  renderVisualGrid()\n                )}\n\n                {/* Cell Edit Panel - shows when a cell is selected */}\n                {editTarget?.type === 'cell' && (\n                  <CellEditPanel\n                    row={editTarget.row}\n                    col={editTarget.col}\n                    isHole={parsedData.holes[editTarget.row]?.[editTarget.col] ?? false}\n                    currentRegion={getRegionLabelAtCell(editedBoard.regions, editTarget.row, editTarget.col)}\n                    availableRegions={parsedData.regionLabels}\n                    onToggleHole={() => toggleCellHole(editTarget.row, editTarget.col)}\n                    onChangeRegion={(label) => changeCellRegion(editTarget.row, editTarget.col, label)}\n                    onClose={() => setEditTarget(null)}\n                  />\n                )}\n\n                {/* Region legend */}\n                <View style={styles.legend}>\n                  {parsedData.regionLabels.map((label, idx) => (\n                    <View key={label} style={styles.legendItem}>\n                      <View\n                        style={[\n                          styles.legendColor,\n                          { backgroundColor: REGION_COLORS[idx % REGION_COLORS.length] },\n                        ]}\n                      />\n                      <Text style={styles.legendText}>{label}</Text>\n                    </View>\n                  ))}\n                </View>\n              </View>\n\n              {/* Visual Constraints (Editable) */}\n              <View style={styles.section}>\n                <Text style={styles.sectionTitle}>Constraints</Text>\n                <Text style={styles.editHint}>Tap constraint value to edit</Text>\n                {Object.entries(editedBoard.constraints || {}).length === 0 ? (\n                  <Text style={styles.textSmall}>No constraints detected</Text>\n                ) : (\n                  <View style={styles.constraintList}>\n                    {Object.entries(editedBoard.constraints).map(([label, constraint]) => (\n                      <TouchableOpacity\n                        key={label}\n                        style={styles.constraintItem}\n                        onPress={() => setEditTarget({ type: 'constraint', regionLabel: label })}\n                      >\n                        <View\n                          style={[\n                            styles.constraintBadge,\n                            {\n                              backgroundColor:\n                                REGION_COLORS[\n                                  parsedData.regionLabels.indexOf(label) % REGION_COLORS.length\n                                ] || colors.surface.slate,\n                            },\n                          ]}\n                        >\n                          <Text style={styles.constraintLabel}>{label}</Text>\n                        </View>\n                        <Text style={styles.constraintValue}>\n                          {constraint.type === 'sum'\n                            ? `${constraint.op || '='} ${constraint.value}`\n                            : constraint.type === 'all_equal'\n                            ? 'all equal'\n                            : constraint.type}\n                        </Text>\n                      </TouchableOpacity>\n                    ))}\n                  </View>\n                )}\n\n                {/* Constraint Edit Panel */}\n                {editTarget?.type === 'constraint' && (\n                  <ConstraintEditPanel\n                    regionLabel={editTarget.regionLabel}\n                    currentConstraint={editedBoard.constraints[editTarget.regionLabel]}\n                    regionColor={\n                      REGION_COLORS[\n                        parsedData.regionLabels.indexOf(editTarget.regionLabel) % REGION_COLORS.length\n                      ] || colors.surface.slate\n                    }\n                    onSave={(type, value, op) =>\n                      handleConstraintChange(editTarget.regionLabel, type, value, op)\n                    }\n                    onDelete={() => deleteConstraint(editTarget.regionLabel)}\n                    onClose={() => setEditTarget(null)}\n                  />\n                )}\n              </View>\n\n              {/* Visual Dominoes */}\n              <View style={styles.section}>\n                <Text style={styles.sectionTitle}>\n                  Dominoes ({editedDominoes.dominoes.length})\n                </Text>\n                {renderVisualDominoes()}\n              </View>\n\n              {/* Confidence Indicators */}\n              {boardResult.confidence && (\n                <View style={styles.section}>\n                  <Text style={styles.sectionTitle}>Confidence</Text>\n                  <View style={styles.confidenceGrid}>\n                    <ConfidenceBar label=\"Grid\" value={boardResult.confidence.grid} />\n                    <ConfidenceBar label=\"Regions\" value={boardResult.confidence.regions} />\n                    <ConfidenceBar label=\"Constraints\" value={boardResult.confidence.constraints} />\n                    {dominoResult.confidence !== undefined && (\n                      <ConfidenceBar label=\"Dominoes\" value={dominoResult.confidence} />\n                    )}\n                  </View>\n                </View>\n              )}\n            </>\n          ) : (\n            <>\n              {/* Text View - Shows current (possibly edited) values */}\n              {/* Grid Info */}\n              <View style={styles.section}>\n                <Text style={styles.sectionTitle}>Grid Dimensions</Text>\n                <Text style={styles.text}>\n                  {editedBoard.rows} rows \u00d7 {editedBoard.cols} columns\n                  {hasEdits && ' (edited)'}\n                </Text>\n                {editedBoard.gridLocation && (\n                  <Text style={styles.textSmall}>\n                    Location: ({editedBoard.gridLocation.left}, {editedBoard.gridLocation.top}) to (\n                    {editedBoard.gridLocation.right}, {editedBoard.gridLocation.bottom})\n                  </Text>\n                )}\n              </View>\n\n              {/* Shape */}\n              <View style={styles.section}>\n                <Text style={styles.sectionTitle}>Shape (# = hole)</Text>\n                <View style={styles.gridContainer}>{formatGrid(editedBoard.shape)}</View>\n              </View>\n\n              {/* Regions */}\n              <View style={styles.section}>\n                <Text style={styles.sectionTitle}>Regions (\u00b7 = unlabeled, # = hole)</Text>\n                <View style={styles.gridContainer}>{formatGrid(editedBoard.regions)}</View>\n              </View>\n\n              {/* Constraints */}\n              <View style={styles.section}>\n                <Text style={styles.sectionTitle}>Constraints</Text>\n                {Object.entries(editedBoard.constraints || {}).length === 0 ? (\n                  <Text style={styles.textSmall}>No constraints detected</Text>\n                ) : (\n                  Object.entries(editedBoard.constraints).map(([label, constraint]) => (\n                    <Text key={label} style={styles.text}>\n                      Region {label}:{' '}\n                      {constraint.type === 'sum'\n                        ? `sum ${constraint.op} ${constraint.value}`\n                        : constraint.type}\n                    </Text>\n                  ))\n                )}\n              </View>\n\n              {/* Dominoes */}\n              <View style={styles.section}>\n                <Text style={styles.sectionTitle}>Dominoes ({editedDominoes.dominoes.length})</Text>\n                <View style={styles.dominoContainer}>\n                  {editedDominoes.dominoes.map((domino, i) => (\n                    <Text key={i} style={styles.domino}>\n                      [{domino[0]},{domino[1]}]\n                    </Text>\n                  ))}\n                </View>\n              </View>\n\n              {/* Confidence (from original extraction) */}\n              {boardResult.confidence && (\n                <View style={styles.section}>\n                  <Text style={styles.sectionTitle}>Original Confidence Scores</Text>\n                  <Text style={styles.text}>\n                    Grid: {Math.round(boardResult.confidence.grid * 100)}%\n                  </Text>\n                  <Text style={styles.text}>\n                    Regions: {Math.round(boardResult.confidence.regions * 100)}%\n                  </Text>\n                  <Text style={styles.text}>\n                    Constraints: {Math.round(boardResult.confidence.constraints * 100)}%\n                  </Text>\n                  {dominoResult.confidence !== undefined && (\n                    <Text style={styles.text}>\n                      Dominoes: {Math.round(dominoResult.confidence * 100)}%\n                    </Text>\n                  )}\n                </View>\n              )}\n            </>\n          )}\n        </ScrollView>\n\n        <View style={styles.buttons}>\n          <TouchableOpacity style={[styles.button, styles.rejectButton]} onPress={onReject}>\n            <Text style={styles.buttonText}>Reject</Text>\n          </TouchableOpacity>\n          <TouchableOpacity\n            style={[styles.button, hasEdits ? styles.acceptButtonEdited : styles.acceptButton]}\n            onPress={handleAccept}\n          >\n            <Text style={styles.buttonText}>\n              {hasEdits ? 'Accept with edits' : 'Accept'}\n            </Text>\n          </TouchableOpacity>\n        </View>\n      </View>\n    </Modal>\n  );\n}\n\n// \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n// Helper Functions\n// \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n/**\n * Calculate the visual center cell for each region (for constraint indicators)\n */\nfunction calculateRegionCenters(\n  regionGrid: (number | null)[][],\n  constraints: Record<string, { type: string; op?: string; value?: number }>\n): Array<{ label: string; row: number; col: number; constraint?: { type: string; value?: number } }> {\n  const regionCells: Record<string, Array<{ row: number; col: number }>> = {};\n\n  // Collect all cells for each region\n  for (let row = 0; row < regionGrid.length; row++) {\n    for (let col = 0; col < (regionGrid[row]?.length ?? 0); col++) {\n      const regionIndex = regionGrid[row][col];\n      if (regionIndex !== null) {\n        const label = String.fromCharCode(65 + regionIndex); // Convert 0 -> 'A', 1 -> 'B', etc.\n        if (!regionCells[label]) {\n          regionCells[label] = [];\n        }\n        regionCells[label].push({ row, col });\n      }\n    }\n  }\n\n  // Calculate center cell for each region\n  return Object.entries(regionCells).map(([label, cells]) => {\n    const avgRow = Math.round(cells.reduce((sum, c) => sum + c.row, 0) / cells.length);\n    const avgCol = Math.round(cells.reduce((sum, c) => sum + c.col, 0) / cells.length);\n\n    // Find the cell closest to the center\n    let minDist = Infinity;\n    let centerCell = cells[0];\n    for (const cell of cells) {\n      const dist = Math.abs(cell.row - avgRow) + Math.abs(cell.col - avgCol);\n      if (dist < minDist) {\n        minDist = dist;\n        centerCell = cell;\n      }\n    }\n\n    return {\n      label,\n      row: centerCell.row,\n      col: centerCell.col,\n      constraint: constraints[label],\n    };\n  });\n}\n\n/**\n * Get pip positions for domino rendering (normalized -1 to 1)\n */\nfunction getPipPositions(value: number): Array<{ x: number; y: number }> {\n  const patterns: Record<number, Array<{ x: number; y: number }>> = {\n    0: [],\n    1: [{ x: 0, y: 0 }],\n    2: [\n      { x: -0.7, y: -0.7 },\n      { x: 0.7, y: 0.7 },\n    ],\n    3: [\n      { x: -0.7, y: -0.7 },\n      { x: 0, y: 0 },\n      { x: 0.7, y: 0.7 },\n    ],\n    4: [\n      { x: -0.7, y: -0.7 },\n      { x: 0.7, y: -0.7 },\n      { x: -0.7, y: 0.7 },\n      { x: 0.7, y: 0.7 },\n    ],\n    5: [\n      { x: -0.7, y: -0.7 },\n      { x: 0.7, y: -0.7 },\n      { x: 0, y: 0 },\n      { x: -0.7, y: 0.7 },\n      { x: 0.7, y: 0.7 },\n    ],\n    6: [\n      { x: -0.7, y: -0.7 },\n      { x: -0.7, y: 0 },\n      { x: -0.7, y: 0.7 },\n      { x: 0.7, y: -0.7 },\n      { x: 0.7, y: 0 },\n      { x: 0.7, y: 0.7 },\n    ],\n  };\n  return patterns[value] || [];\n}\n\n/**\n * Get the region label at a specific cell position\n */\nfunction getRegionLabelAtCell(regionsStr: string, row: number, col: number): string | null {\n  const lines = regionsStr.split('\\\\n').filter(line => line.length > 0);\n  const char = lines[row]?.[col];\n  if (!char || char === '#' || char === '.') return null;\n  return char;\n}\n\n/**\n * Resize shape string when grid dimensions change\n * @param shapeStr - Current shape string (e.g., \"OOO\\nOOO\\nOOO\")\n * @param currentRows - Current number of rows\n * @param currentCols - Current number of columns\n * @param newRows - New number of rows\n * @param newCols - New number of columns\n * @returns Resized shape string\n */\nfunction resizeShapeString(\n  shapeStr: string,\n  currentRows: number,\n  currentCols: number,\n  newRows: number,\n  newCols: number\n): string {\n  const lines = shapeStr.split('\\\\n').filter(line => line.length > 0);\n\n  // Build new shape grid\n  const newLines: string[] = [];\n  for (let row = 0; row < newRows; row++) {\n    let newLine = '';\n    for (let col = 0; col < newCols; col++) {\n      if (row < currentRows && col < currentCols) {\n        // Preserve existing cell\n        newLine += lines[row]?.[col] ?? 'O';\n      } else {\n        // New cell - default to active (O)\n        newLine += 'O';\n      }\n    }\n    newLines.push(newLine);\n  }\n\n  return newLines.join('\\\\n');\n}\n\n/**\n * Resize regions string when grid dimensions change\n * @param regionsStr - Current regions string (e.g., \"AAB\\nABB\\nCCC\")\n * @param currentRows - Current number of rows\n * @param currentCols - Current number of columns\n * @param newRows - New number of rows\n * @param newCols - New number of columns\n * @returns Resized regions string\n */\nfunction resizeRegionsString(\n  regionsStr: string,\n  currentRows: number,\n  currentCols: number,\n  newRows: number,\n  newCols: number\n): string {\n  const lines = regionsStr.split('\\\\n').filter(line => line.length > 0);\n\n  // Build new regions grid\n  const newLines: string[] = [];\n  for (let row = 0; row < newRows; row++) {\n    let newLine = '';\n    for (let col = 0; col < newCols; col++) {\n      if (row < currentRows && col < currentCols) {\n        // Preserve existing cell\n        newLine += lines[row]?.[col] ?? 'A';\n      } else {\n        // New cell - default to first region (A)\n        newLine += 'A';\n      }\n    }\n    newLines.push(newLine);\n  }\n\n  return newLines.join('\\\\n');\n}\n\n/**\n * Check if resizing dimensions would lose any non-hole cells\n * @returns true if cells would be orphaned (lost)\n */\nfunction wouldOrphanCells(\n  shapeStr: string,\n  currentRows: number,\n  currentCols: number,\n  newRows: number,\n  newCols: number\n): boolean {\n  if (newRows >= currentRows && newCols >= currentCols) {\n    return false; // Expanding only, no cells lost\n  }\n\n  const lines = shapeStr.split('\\\\n').filter(line => line.length > 0);\n\n  // Check cells that would be removed\n  for (let row = 0; row < currentRows; row++) {\n    for (let col = 0; col < currentCols; col++) {\n      const wouldBeRemoved = row >= newRows || col >= newCols;\n      if (wouldBeRemoved) {\n        const char = lines[row]?.[col];\n        // If this cell is not a hole (is active), it would be orphaned\n        if (char && char !== '#') {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * Confidence bar component for visual display\n */\nfunction ConfidenceBar({ label, value }: { label: string; value: number }) {\n  const percentage = Math.round(value * 100);\n  const barColor =\n    percentage >= 90\n      ? colors.semantic.jade\n      : percentage >= 80\n      ? colors.semantic.amber\n      : colors.semantic.coral;\n\n  return (\n    <View style={confidenceBarStyles.container}>\n      <Text style={confidenceBarStyles.label}>{label}</Text>\n      <View style={confidenceBarStyles.barBackground}>\n        <View\n          style={[\n            confidenceBarStyles.barFill,\n            { width: `${percentage}%`, backgroundColor: barColor },\n          ]}\n        />\n      </View>\n      <Text style={[confidenceBarStyles.value, { color: barColor }]}>{percentage}%</Text>\n    </View>\n  );\n}\n\nconst confidenceBarStyles = StyleSheet.create({\n  container: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    marginBottom: spacing[2],\n  },\n  label: {\n    width: 80,\n    fontSize: 12,\n    color: colors.text.secondary,\n  },\n  barBackground: {\n    flex: 1,\n    height: 8,\n    backgroundColor: colors.surface.slate,\n    borderRadius: radii.full,\n    overflow: 'hidden',\n    marginHorizontal: spacing[2],\n  },\n  barFill: {\n    height: '100%',\n    borderRadius: radii.full,\n  },\n  value: {\n    width: 40,\n    fontSize: 12,\n    fontWeight: '600',\n    textAlign: 'right',\n  },\n});\n\n// \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n// Cell Edit Panel Component\n// \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\ninterface CellEditPanelProps {\n  row: number;\n  col: number;\n  isHole: boolean;\n  currentRegion: string | null;\n  availableRegions: string[];\n  onToggleHole: () => void;\n  onChangeRegion: (label: string) => void;\n  onClose: () => void;\n}\n\nfunction CellEditPanel({\n  row,\n  col,\n  isHole,\n  currentRegion,\n  availableRegions,\n  onToggleHole,\n  onChangeRegion,\n  onClose,\n}: CellEditPanelProps) {\n  return (\n    <View style={cellEditStyles.container}>\n      <View style={cellEditStyles.header}>\n        <Text style={cellEditStyles.title}>\n          Edit Cell ({row + 1}, {col + 1})\n        </Text>\n        <TouchableOpacity onPress={onClose} style={cellEditStyles.closeButton}>\n          <Text style={cellEditStyles.closeText}>\u00d7</Text>\n        </TouchableOpacity>\n      </View>\n\n      {/* Toggle hole/cell */}\n      <TouchableOpacity style={cellEditStyles.actionButton} onPress={onToggleHole}>\n        <Text style={cellEditStyles.actionText}>\n          {isHole ? 'Convert to Cell' : 'Mark as Hole'}\n        </Text>\n      </TouchableOpacity>\n\n      {/* Region selection (only if not a hole) */}\n      {!isHole && (\n        <View style={cellEditStyles.regionSection}>\n          <Text style={cellEditStyles.sectionLabel}>Change Region:</Text>\n          <View style={cellEditStyles.regionButtons}>\n            {availableRegions.map((label, idx) => (\n              <TouchableOpacity\n                key={label}\n                style={[\n                  cellEditStyles.regionButton,\n                  {\n                    backgroundColor: REGION_COLORS[idx % REGION_COLORS.length],\n                    borderWidth: currentRegion === label ? 3 : 0,\n                    borderColor: colors.accent.brass,\n                  },\n                ]}\n                onPress={() => onChangeRegion(label)}\n              >\n                <Text style={cellEditStyles.regionButtonText}>{label}</Text>\n              </TouchableOpacity>\n            ))}\n          </View>\n        </View>\n      )}\n    </View>\n  );\n}\n\nconst cellEditStyles = StyleSheet.create({\n  container: {\n    backgroundColor: colors.surface.graphite,\n    borderRadius: radii.lg,\n    padding: spacing[4],\n    marginTop: spacing[3],\n  },\n  header: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    marginBottom: spacing[3],\n  },\n  title: {\n    fontSize: 16,\n    fontWeight: '600',\n    color: colors.text.primary,\n  },\n  closeButton: {\n    width: 28,\n    height: 28,\n    borderRadius: radii.full,\n    backgroundColor: colors.surface.ash,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  closeText: {\n    fontSize: 20,\n    color: colors.text.primary,\n    marginTop: -2,\n  },\n  actionButton: {\n    backgroundColor: colors.surface.slate,\n    borderRadius: radii.md,\n    padding: spacing[3],\n    alignItems: 'center',\n    marginBottom: spacing[3],\n  },\n  actionText: {\n    fontSize: 14,\n    fontWeight: '500',\n    color: colors.text.primary,\n  },\n  regionSection: {\n    marginTop: spacing[2],\n  },\n  sectionLabel: {\n    fontSize: 12,\n    color: colors.text.secondary,\n    marginBottom: spacing[2],\n  },\n  regionButtons: {\n    flexDirection: 'row',\n    flexWrap: 'wrap',\n    gap: spacing[2],\n  },\n  regionButton: {\n    width: 36,\n    height: 36,\n    borderRadius: radii.md,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  regionButtonText: {\n    fontSize: 14,\n    fontWeight: '700',\n    color: colors.text.primary,\n  },\n});\n\n// \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n// Constraint Edit Panel Component\n// \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\ninterface ConstraintEditPanelProps {\n  regionLabel: string;\n  currentConstraint?: { type: string; op?: string; value?: number };\n  regionColor: string;\n  onSave: (type: string, value?: number, op?: string) => void;\n  onDelete: () => void;\n  onClose: () => void;\n}\n\nfunction ConstraintEditPanel({\n  regionLabel,\n  currentConstraint,\n  regionColor,\n  onSave,\n  onDelete,\n  onClose,\n}: ConstraintEditPanelProps) {\n  const [constraintType, setConstraintType] = useState(currentConstraint?.type || 'sum');\n  const [constraintValue, setConstraintValue] = useState(\n    currentConstraint?.value?.toString() || ''\n  );\n  const [constraintOp, setConstraintOp] = useState(currentConstraint?.op || '==');\n\n  const handleSave = () => {\n    const value = constraintValue ? parseInt(constraintValue, 10) : undefined;\n    onSave(constraintType, value, constraintOp);\n  };\n\n  return (\n    <View style={constraintEditStyles.container}>\n      <View style={constraintEditStyles.header}>\n        <View style={constraintEditStyles.headerLeft}>\n          <View style={[constraintEditStyles.regionBadge, { backgroundColor: regionColor }]}>\n            <Text style={constraintEditStyles.regionLabel}>{regionLabel}</Text>\n          </View>\n          <Text style={constraintEditStyles.title}>Edit Constraint</Text>\n        </View>\n        <TouchableOpacity onPress={onClose} style={constraintEditStyles.closeButton}>\n          <Text style={constraintEditStyles.closeText}>\u00d7</Text>\n        </TouchableOpacity>\n      </View>\n\n      {/* Constraint type selection */}\n      <View style={constraintEditStyles.typeSection}>\n        <Text style={constraintEditStyles.sectionLabel}>Type:</Text>\n        <View style={constraintEditStyles.typeButtons}>\n          {['sum', 'all_equal'].map(type => (\n            <TouchableOpacity\n              key={type}\n              style={[\n                constraintEditStyles.typeButton,\n                constraintType === type && constraintEditStyles.typeButtonActive,\n              ]}\n              onPress={() => setConstraintType(type)}\n            >\n              <Text\n                style={[\n                  constraintEditStyles.typeButtonText,\n                  constraintType === type && constraintEditStyles.typeButtonTextActive,\n                ]}\n              >\n                {type === 'sum' ? 'Sum' : 'All Equal'}\n              </Text>\n            </TouchableOpacity>\n          ))}\n        </View>\n      </View>\n\n      {/* Value input for sum constraints */}\n      {constraintType === 'sum' && (\n        <View style={constraintEditStyles.valueSection}>\n          <View style={constraintEditStyles.opSection}>\n            <Text style={constraintEditStyles.sectionLabel}>Operator:</Text>\n            <View style={constraintEditStyles.opButtons}>\n              {['==', '<', '>', '!='].map(op => (\n                <TouchableOpacity\n                  key={op}\n                  style={[\n                    constraintEditStyles.opButton,\n                    constraintOp === op && constraintEditStyles.opButtonActive,\n                  ]}\n                  onPress={() => setConstraintOp(op)}\n                >\n                  <Text\n                    style={[\n                      constraintEditStyles.opButtonText,\n                      constraintOp === op && constraintEditStyles.opButtonTextActive,\n                    ]}\n                  >\n                    {op}\n                  </Text>\n                </TouchableOpacity>\n              ))}\n            </View>\n          </View>\n\n          <View style={constraintEditStyles.inputSection}>\n            <Text style={constraintEditStyles.sectionLabel}>Value:</Text>\n            <TextInput\n              style={constraintEditStyles.valueInput}\n              value={constraintValue}\n              onChangeText={setConstraintValue}\n              keyboardType=\"number-pad\"\n              placeholder=\"0\"\n              placeholderTextColor={colors.text.tertiary}\n            />\n          </View>\n        </View>\n      )}\n\n      {/* Action buttons */}\n      <View style={constraintEditStyles.actions}>\n        <TouchableOpacity style={constraintEditStyles.deleteButton} onPress={onDelete}>\n          <Text style={constraintEditStyles.deleteButtonText}>Delete</Text>\n        </TouchableOpacity>\n        <TouchableOpacity style={constraintEditStyles.saveButton} onPress={handleSave}>\n          <Text style={constraintEditStyles.saveButtonText}>Save</Text>\n        </TouchableOpacity>\n      </View>\n    </View>\n  );\n}\n\nconst constraintEditStyles = StyleSheet.create({\n  container: {\n    backgroundColor: colors.surface.graphite,\n    borderRadius: radii.lg,\n    padding: spacing[4],\n    marginTop: spacing[3],\n  },\n  header: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    marginBottom: spacing[4],\n  },\n  headerLeft: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    gap: spacing[2],\n  },\n  regionBadge: {\n    width: 28,\n    height: 28,\n    borderRadius: radii.sm,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  regionLabel: {\n    fontSize: 14,\n    fontWeight: '700',\n    color: colors.text.primary,\n  },\n  title: {\n    fontSize: 16,\n    fontWeight: '600',\n    color: colors.text.primary,\n  },\n  closeButton: {\n    width: 28,\n    height: 28,\n    borderRadius: radii.full,\n    backgroundColor: colors.surface.ash,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  closeText: {\n    fontSize: 20,\n    color: colors.text.primary,\n    marginTop: -2,\n  },\n  typeSection: {\n    marginBottom: spacing[4],\n  },\n  sectionLabel: {\n    fontSize: 12,\n    color: colors.text.secondary,\n    marginBottom: spacing[2],\n  },\n  typeButtons: {\n    flexDirection: 'row',\n    gap: spacing[2],\n  },\n  typeButton: {\n    flex: 1,\n    paddingVertical: spacing[2],\n    paddingHorizontal: spacing[3],\n    backgroundColor: colors.surface.slate,\n    borderRadius: radii.md,\n    alignItems: 'center',\n  },\n  typeButtonActive: {\n    backgroundColor: colors.accent.brass,\n  },\n  typeButtonText: {\n    fontSize: 14,\n    fontWeight: '500',\n    color: colors.text.secondary,\n  },\n  typeButtonTextActive: {\n    color: colors.text.inverse,\n  },\n  valueSection: {\n    marginBottom: spacing[4],\n  },\n  opSection: {\n    marginBottom: spacing[3],\n  },\n  opButtons: {\n    flexDirection: 'row',\n    gap: spacing[2],\n  },\n  opButton: {\n    paddingVertical: spacing[2],\n    paddingHorizontal: spacing[3],\n    backgroundColor: colors.surface.slate,\n    borderRadius: radii.md,\n    minWidth: 44,\n    alignItems: 'center',\n  },\n  opButtonActive: {\n    backgroundColor: colors.accent.brass,\n  },\n  opButtonText: {\n    fontSize: 14,\n    fontWeight: '500',\n    color: colors.text.secondary,\n  },\n  opButtonTextActive: {\n    color: colors.text.inverse,\n  },\n  inputSection: {},\n  valueInput: {\n    backgroundColor: colors.surface.slate,\n    borderRadius: radii.md,\n    padding: spacing[3],\n    fontSize: 18,\n    fontWeight: '600',\n    color: colors.text.primary,\n    textAlign: 'center',\n  },\n  actions: {\n    flexDirection: 'row',\n    gap: spacing[3],\n    marginTop: spacing[2],\n  },\n  deleteButton: {\n    flex: 1,\n    paddingVertical: spacing[3],\n    backgroundColor: colors.semantic.coral,\n    borderRadius: radii.md,\n    alignItems: 'center',\n  },\n  deleteButtonText: {\n    fontSize: 14,\n    fontWeight: '600',\n    color: colors.text.primary,\n  },\n  saveButton: {\n    flex: 2,\n    paddingVertical: spacing[3],\n    backgroundColor: colors.semantic.jade,\n    borderRadius: radii.md,\n    alignItems: 'center',\n  },\n  saveButtonText: {\n    fontSize: 14,\n    fontWeight: '600',\n    color: colors.text.inverse,\n  },\n});\n\n// \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n// Grid Dimension Edit Panel Component\n// \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\ninterface GridDimensionEditPanelProps {\n  rows: number;\n  cols: number;\n  onRowChange: (delta: number) => void;\n  onColChange: (delta: number) => void;\n  onClose: () => void;\n}\n\nfunction GridDimensionEditPanel({\n  rows,\n  cols,\n  onRowChange,\n  onColChange,\n  onClose,\n}: GridDimensionEditPanelProps) {\n  return (\n    <View style={dimensionEditStyles.container}>\n      <View style={dimensionEditStyles.header}>\n        <Text style={dimensionEditStyles.title}>Edit Dimensions</Text>\n        <TouchableOpacity onPress={onClose} style={dimensionEditStyles.closeButton}>\n          <Text style={dimensionEditStyles.closeText}>\u00d7</Text>\n        </TouchableOpacity>\n      </View>\n\n      <Text style={dimensionEditStyles.hint}>\n        Adjust grid size. Min: {MIN_DIMENSION}, Max: {MAX_DIMENSION}\n      </Text>\n\n      {/* Row controls */}\n      <View style={dimensionEditStyles.controlRow}>\n        <Text style={dimensionEditStyles.controlLabel}>Rows</Text>\n        <View style={dimensionEditStyles.controlButtons}>\n          <TouchableOpacity\n            style={[\n              dimensionEditStyles.controlButton,\n              rows <= MIN_DIMENSION && dimensionEditStyles.controlButtonDisabled,\n            ]}\n            onPress={() => onRowChange(-1)}\n            disabled={rows <= MIN_DIMENSION}\n          >\n            <Text\n              style={[\n                dimensionEditStyles.controlButtonText,\n                rows <= MIN_DIMENSION && dimensionEditStyles.controlButtonTextDisabled,\n              ]}\n            >\n              \u2212\n            </Text>\n          </TouchableOpacity>\n          <Text style={dimensionEditStyles.controlValue}>{rows}</Text>\n          <TouchableOpacity\n            style={[\n              dimensionEditStyles.controlButton,\n              rows >= MAX_DIMENSION && dimensionEditStyles.controlButtonDisabled,\n            ]}\n            onPress={() => onRowChange(1)}\n            disabled={rows >= MAX_DIMENSION}\n          >\n            <Text\n              style={[\n                dimensionEditStyles.controlButtonText,\n                rows >= MAX_DIMENSION && dimensionEditStyles.controlButtonTextDisabled,\n              ]}\n            >\n              +\n            </Text>\n          </TouchableOpacity>\n        </View>\n      </View>\n\n      {/* Column controls */}\n      <View style={dimensionEditStyles.controlRow}>\n        <Text style={dimensionEditStyles.controlLabel}>Columns</Text>\n        <View style={dimensionEditStyles.controlButtons}>\n          <TouchableOpacity\n            style={[\n              dimensionEditStyles.controlButton,\n              cols <= MIN_DIMENSION && dimensionEditStyles.controlButtonDisabled,\n            ]}\n            onPress={() => onColChange(-1)}\n            disabled={cols <= MIN_DIMENSION}\n          >\n            <Text\n              style={[\n                dimensionEditStyles.controlButtonText,\n                cols <= MIN_DIMENSION && dimensionEditStyles.controlButtonTextDisabled,\n              ]}\n            >\n              \u2212\n            </Text>\n          </TouchableOpacity>\n          <Text style={dimensionEditStyles.controlValue}>{cols}</Text>\n          <TouchableOpacity\n            style={[\n              dimensionEditStyles.controlButton,\n              cols >= MAX_DIMENSION && dimensionEditStyles.controlButtonDisabled,\n            ]}\n            onPress={() => onColChange(1)}\n            disabled={cols >= MAX_DIMENSION}\n          >\n            <Text\n              style={[\n                dimensionEditStyles.controlButtonText,\n                cols >= MAX_DIMENSION && dimensionEditStyles.controlButtonTextDisabled,\n              ]}\n            >\n              +\n            </Text>\n          </TouchableOpacity>\n        </View>\n      </View>\n    </View>\n  );\n}\n\nconst dimensionEditStyles = StyleSheet.create({\n  container: {\n    backgroundColor: colors.surface.graphite,\n    borderRadius: radii.lg,\n    padding: spacing[4],\n    marginTop: spacing[3],\n  },\n  header: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    marginBottom: spacing[3],\n  },\n  title: {\n    fontSize: 16,\n    fontWeight: '600',\n    color: colors.text.primary,\n  },\n  closeButton: {\n    width: 28,\n    height: 28,\n    borderRadius: radii.full,\n    backgroundColor: colors.surface.ash,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  closeText: {\n    fontSize: 20,\n    color: colors.text.primary,\n    marginTop: -2,\n  },\n  hint: {\n    fontSize: 12,\n    color: colors.text.tertiary,\n    fontStyle: 'italic',\n    marginBottom: spacing[4],\n  },\n  controlRow: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'space-between',\n    marginBottom: spacing[3],\n  },\n  controlLabel: {\n    fontSize: 14,\n    fontWeight: '500',\n    color: colors.text.secondary,\n  },\n  controlButtons: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    gap: spacing[2],\n  },\n  controlButton: {\n    width: 40,\n    height: 40,\n    backgroundColor: colors.surface.slate,\n    borderRadius: radii.md,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  controlButtonDisabled: {\n    backgroundColor: colors.surface.ash,\n    opacity: 0.5,\n  },\n  controlButtonText: {\n    fontSize: 22,\n    fontWeight: '600',\n    color: colors.text.primary,\n  },\n  controlButtonTextDisabled: {\n    color: colors.text.tertiary,\n  },\n  controlValue: {\n    fontSize: 18,\n    fontWeight: '600',\n    color: colors.text.primary,\n    width: 36,\n    textAlign: 'center',\n  },\n});\n\n// \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n// Styles\n// \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: colors.surface.charcoal,\n  },\n  header: {\n    padding: spacing[5],\n    borderBottomWidth: 1,\n    borderBottomColor: colors.surface.ash,\n  },\n  title: {\n    fontSize: 24,\n    fontWeight: 'bold',\n    color: colors.text.primary,\n    marginBottom: spacing[1],\n  },\n  subtitle: {\n    fontSize: 14,\n    color: colors.text.secondary,\n  },\n  viewToggle: {\n    flexDirection: 'row',\n    marginTop: spacing[3],\n    backgroundColor: colors.surface.slate,\n    borderRadius: radii.md,\n    padding: spacing[1],\n  },\n  toggleButton: {\n    flex: 1,\n    paddingVertical: spacing[2],\n    alignItems: 'center',\n    borderRadius: radii.sm,\n  },\n  toggleButtonActive: {\n    backgroundColor: colors.accent.brass,\n  },\n  toggleText: {\n    fontSize: 14,\n    fontWeight: '500',\n    color: colors.text.secondary,\n  },\n  toggleTextActive: {\n    color: colors.text.inverse,\n  },\n  content: {\n    flex: 1,\n  },\n  contentContainer: {\n    padding: spacing[5],\n  },\n  section: {\n    marginBottom: spacing[6],\n  },\n  sectionHeader: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    marginBottom: spacing[3],\n  },\n  sectionTitle: {\n    fontSize: 16,\n    fontWeight: '600',\n    color: colors.text.primary,\n    marginBottom: spacing[2],\n  },\n  overlayToggle: {\n    paddingHorizontal: spacing[3],\n    paddingVertical: spacing[1],\n    backgroundColor: colors.surface.slate,\n    borderRadius: radii.sm,\n  },\n  overlayToggleText: {\n    fontSize: 12,\n    color: colors.text.secondary,\n  },\n  text: {\n    fontSize: 14,\n    color: colors.text.secondary,\n    marginBottom: spacing[1],\n  },\n  textSmall: {\n    fontSize: 12,\n    color: colors.text.tertiary,\n    marginTop: spacing[1],\n  },\n  // Text view styles\n  gridContainer: {\n    backgroundColor: colors.surface.obsidian,\n    padding: spacing[3],\n    borderRadius: radii.md,\n    alignSelf: 'flex-start',\n  },\n  gridLine: {\n    fontFamily: 'Courier',\n    fontSize: 18,\n    lineHeight: 24,\n  },\n  gridChar: {\n    color: colors.text.primary,\n    marginRight: spacing[2],\n  },\n  holeChar: {\n    color: colors.text.tertiary,\n  },\n  emptyChar: {\n    color: colors.text.secondary,\n  },\n  dominoContainer: {\n    flexDirection: 'row',\n    flexWrap: 'wrap',\n    gap: spacing[2],\n  },\n  domino: {\n    fontSize: 14,\n    color: colors.text.secondary,\n    backgroundColor: colors.surface.slate,\n    paddingHorizontal: spacing[2],\n    paddingVertical: spacing[1],\n    borderRadius: radii.sm,\n    fontFamily: 'Courier',\n  },\n  // Visual view styles\n  visualGridContainer: {\n    alignSelf: 'center',\n    marginBottom: spacing[3],\n  },\n  imageOverlayContainer: {\n    alignSelf: 'center',\n    position: 'relative',\n  },\n  sourceImage: {\n    borderRadius: radii.md,\n    opacity: 0.6,\n  },\n  overlayGrid: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    opacity: 0.8,\n  },\n  legend: {\n    flexDirection: 'row',\n    flexWrap: 'wrap',\n    gap: spacing[2],\n    marginTop: spacing[2],\n  },\n  legendItem: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    backgroundColor: colors.surface.slate,\n    paddingHorizontal: spacing[2],\n    paddingVertical: spacing[1],\n    borderRadius: radii.sm,\n  },\n  legendColor: {\n    width: 16,\n    height: 16,\n    borderRadius: radii.sm,\n    marginRight: spacing[1],\n  },\n  legendText: {\n    fontSize: 12,\n    fontWeight: '600',\n    color: colors.text.primary,\n  },\n  constraintList: {\n    flexDirection: 'row',\n    flexWrap: 'wrap',\n    gap: spacing[2],\n  },\n  constraintItem: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    backgroundColor: colors.surface.slate,\n    paddingHorizontal: spacing[3],\n    paddingVertical: spacing[2],\n    borderRadius: radii.md,\n  },\n  constraintBadge: {\n    width: 24,\n    height: 24,\n    borderRadius: radii.sm,\n    alignItems: 'center',\n    justifyContent: 'center',\n    marginRight: spacing[2],\n  },\n  constraintLabel: {\n    fontSize: 12,\n    fontWeight: '700',\n    color: colors.text.primary,\n  },\n  constraintValue: {\n    fontSize: 14,\n    color: colors.text.secondary,\n  },\n  visualDominoContainer: {\n    flexDirection: 'row',\n    flexWrap: 'wrap',\n    gap: spacing[2],\n  },\n  visualDomino: {\n    flexDirection: 'row',\n    alignItems: 'center',\n    backgroundColor: colors.domino.ivory,\n    borderRadius: radii.sm,\n    padding: spacing[1],\n    borderWidth: 1,\n    borderColor: colors.domino.border,\n  },\n  dominoHalf: {\n    width: 22,\n    height: 22,\n    position: 'relative',\n  },\n  dominoDivider: {\n    width: 1,\n    height: 18,\n    backgroundColor: colors.domino.ivoryDark,\n    marginHorizontal: 2,\n  },\n  pipContainer: {\n    width: '100%',\n    height: '100%',\n    position: 'relative',\n  },\n  pip: {\n    position: 'absolute',\n    width: 4,\n    height: 4,\n    borderRadius: 2,\n    backgroundColor: colors.domino.pip,\n    transform: [{ translateX: -2 }, { translateY: -2 }],\n  },\n  confidenceGrid: {\n    marginTop: spacing[2],\n  },\n  buttons: {\n    flexDirection: 'row',\n    padding: spacing[4],\n    gap: spacing[3],\n    borderTopWidth: 1,\n    borderTopColor: colors.surface.ash,\n  },\n  button: {\n    flex: 1,\n    paddingVertical: spacing[4],\n    borderRadius: radii.md,\n    alignItems: 'center',\n  },\n  rejectButton: {\n    backgroundColor: colors.surface.graphite,\n  },\n  acceptButton: {\n    backgroundColor: colors.semantic.jade,\n  },\n  acceptButtonEdited: {\n    backgroundColor: colors.accent.brass,\n  },\n  buttonText: {\n    color: colors.text.primary,\n    fontSize: 16,\n    fontWeight: '600',\n  },\n  // Header editing mode styles\n  headerRow: {\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'flex-start',\n  },\n  resetButton: {\n    paddingHorizontal: spacing[3],\n    paddingVertical: spacing[2],\n    backgroundColor: colors.surface.slate,\n    borderRadius: radii.md,\n  },\n  resetButtonText: {\n    fontSize: 12,\n    fontWeight: '500',\n    color: colors.text.secondary,\n  },\n  editBadge: {\n    alignSelf: 'flex-start',\n    marginTop: spacing[2],\n    paddingHorizontal: spacing[2],\n    paddingVertical: spacing[1],\n    backgroundColor: colors.accent.brass,\n    borderRadius: radii.sm,\n  },\n  editBadgeText: {\n    fontSize: 11,\n    fontWeight: '600',\n    color: colors.text.inverse,\n  },\n  editHint: {\n    fontSize: 12,\n    color: colors.text.tertiary,\n    fontStyle: 'italic',\n    marginBottom: spacing[2],\n  },\n  // Cell touch overlay styles\n  cellTouchOverlay: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n  },\n  cellTouchTarget: {\n    position: 'absolute',\n    backgroundColor: 'transparent',\n  },\n  // Domino editing styles\n  dominoHalfTouchable: {\n    borderRadius: radii.sm,\n  },\n  dominoIndex: {\n    fontSize: 8,\n    color: colors.text.tertiary,\n    marginLeft: spacing[1],\n  },\n});\n",
        "timestamp": "2025-12-22T10:40:59.869651"
      },
      "worktree_state": null,
      "task_intent": {
        "title": "009-ai-verification-modal-lacks-keyboard-accessibility",
        "description": "",
        "from_plan": false
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2025-12-22T03:09:27.992889",
  "last_updated": "2025-12-22T10:40:59.915418"
}