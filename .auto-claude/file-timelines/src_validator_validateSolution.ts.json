{
  "file_path": "src/validator/validateSolution.ts",
  "main_branch_history": [],
  "task_views": {
    "004-add-cross-stage-confidence-warnings-to-ui": {
      "task_id": "004-add-cross-stage-confidence-warnings-to-ui",
      "branch_point": {
        "commit_hash": "faf3f69f9b2794c6a85ffd2581461d3d68bdf8ef",
        "content": "",
        "timestamp": "2025-12-22T03:09:58.791154"
      },
      "worktree_state": {
        "content": "import { PuzzleSpec, SolutionGrid, ValidationIssue, ValidationReport } from '../model/types';\n\nfunction unorderedId(a: number, b: number) {\n  return a <= b ? `${a}-${b}` : `${b}-${a}`;\n}\n\nexport function validateSolution(puzzle: PuzzleSpec, solution: SolutionGrid): ValidationReport {\n  const issues: ValidationIssue[] = [];\n  if (solution.gridPips.length !== puzzle.rows) {\n    issues.push({ level: 'error', message: 'Solution rows mismatch' });\n  }\n  solution.gridPips.forEach((row, r) => {\n    if (row.length !== puzzle.cols) {\n      issues.push({ level: 'error', message: `Solution cols mismatch at row ${r}` });\n    }\n  });\n\n  const seenCells: Record<string, boolean> = {};\n  solution.dominoes.forEach((d) => {\n    const [[r1, c1], [r2, c2]] = d.cells;\n    const key1 = `${r1},${c1}`;\n    const key2 = `${r2},${c2}`;\n    if (seenCells[key1] || seenCells[key2]) {\n      issues.push({ level: 'error', message: `Cell reused in domino ${d.id}` });\n    }\n    seenCells[key1] = true;\n    seenCells[key2] = true;\n    const dist = Math.abs(r1 - r2) + Math.abs(c1 - c2);\n    if (dist !== 1) {\n      issues.push({ level: 'error', message: `Domino ${d.id} not orthogonally adjacent` });\n    }\n  });\n\n  const expectedCells = puzzle.rows * puzzle.cols;\n  const covered = Object.keys(seenCells).length;\n  if (covered !== expectedCells) {\n    issues.push({ level: 'error', message: `Domino coverage mismatch (${covered}/${expectedCells})` });\n  }\n\n  // region constraints\n  Object.entries(puzzle.regionConstraints).forEach(([id, constraint]) => {\n    const cells: [number, number][] = [];\n    puzzle.regions.forEach((row, r) =>\n      row.forEach((regionId, c) => {\n        if (regionId === Number(id)) cells.push([r, c]);\n      }),\n    );\n    const values = cells.map(([r, c]) => solution.gridPips[r][c]);\n    if (constraint.type === 'sum') {\n      const s = values.reduce((a, b) => a + b, 0);\n      if (s !== constraint.value) {\n        issues.push({ level: 'error', message: `Region ${id} sum ${s} != ${constraint.value}` });\n      }\n    } else if (constraint.type === 'op') {\n      const s = values.reduce((a, b) => a + b, 0);\n      if (constraint.op === '=' && s !== constraint.value) {\n        issues.push({ level: 'error', message: `Region ${id} must equal ${constraint.value}` });\n      }\n      if (constraint.op === '<' && !(s < constraint.value)) issues.push({ level: 'error', message: `Region ${id} < ${constraint.value}` });\n      if (constraint.op === '>' && !(s > constraint.value)) issues.push({ level: 'error', message: `Region ${id} > ${constraint.value}` });\n      if (constraint.op === '\u2260' && s === constraint.value) issues.push({ level: 'error', message: `Region ${id} \u2260 ${constraint.value}` });\n    } else if (constraint.type === 'all_equal') {\n      const unique = new Set(values);\n      if (unique.size !== 1) {\n        issues.push({ level: 'error', message: `Region ${id} not all equal` });\n      }\n    }\n  });\n\n  // domino uniqueness\n  const seenDomino: Record<string, number> = {};\n  solution.dominoes.forEach((d) => {\n    const pair = unorderedId(d.values[0], d.values[1]);\n    seenDomino[pair] = (seenDomino[pair] ?? 0) + 1;\n  });\n  if (!puzzle.allowDuplicates) {\n    Object.entries(seenDomino).forEach(([pair, count]) => {\n      if (count > 1) {\n        issues.push({ level: 'error', message: `Domino ${pair} reused ${count} times` });\n      }\n    });\n  }\n\n  return { ok: !issues.some((i) => i.level === 'error'), issues };\n}\n",
        "last_modified": "2025-12-22T03:10:02.283120"
      },
      "task_intent": {
        "title": "004-add-cross-stage-confidence-warnings-to-ui",
        "description": "Display the confidence hints generated by generateConfidenceHints() in the mobile app's extraction results screen. The backend already computes these hints but the UI only shows the overall confidence percentage.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2025-12-22T03:10:01.723702",
  "last_updated": "2025-12-22T03:10:01.824291"
}