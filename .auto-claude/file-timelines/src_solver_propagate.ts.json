{
  "file_path": "src/solver/propagate.ts",
  "main_branch_history": [],
  "task_views": {
    "004-add-cross-stage-confidence-warnings-to-ui": {
      "task_id": "004-add-cross-stage-confidence-warnings-to-ui",
      "branch_point": {
        "commit_hash": "faf3f69f9b2794c6a85ffd2581461d3d68bdf8ef",
        "content": "",
        "timestamp": "2025-12-22T03:09:58.791154"
      },
      "worktree_state": {
        "content": "import { NormalizedPuzzle } from '../model/normalize';\nimport { DomainMap } from './types';\n\nexport interface PropagationResult {\n  domains: DomainMap;\n  pruned: number;\n  conflict?: string;\n}\n\nexport function cloneDomains(domains: DomainMap): DomainMap {\n  const next: DomainMap = {};\n  Object.keys(domains).forEach((key) => {\n    next[key] = [...domains[key]];\n  });\n  return next;\n}\n\nexport function propagateRegionBounds(\n  puzzle: NormalizedPuzzle,\n  domains: DomainMap,\n  assignment: Map<string, number>,\n): PropagationResult {\n  let pruned = 0;\n  for (const [regionId, cells] of Object.entries(puzzle.regionCells)) {\n    const constraint = puzzle.regionConstraints[Number(regionId)];\n    if (!constraint) continue;\n    const remainingCells: string[] = [];\n    let assignedSum = 0;\n    cells.forEach(([r, c]) => {\n      const key = `${r},${c}`;\n      if (assignment.has(key)) {\n        assignedSum += assignment.get(key) ?? 0;\n      } else {\n        remainingCells.push(key);\n      }\n    });\n    const maxDomainVal = puzzle.maxPip ?? 6;\n    const minDomainVal = 0;\n    const minPossible = assignedSum + remainingCells.length * minDomainVal;\n    const maxPossible = assignedSum + remainingCells.length * maxDomainVal;\n\n    if (constraint.type === 'sum') {\n      if (constraint.value < minPossible || constraint.value > maxPossible) {\n        return { domains, pruned, conflict: `Region ${regionId} cannot meet sum ${constraint.value}` };\n      }\n      // tighten domains roughly\n      const slack = constraint.value - assignedSum;\n      remainingCells.forEach((key) => {\n        const domain = domains[key];\n        const filtered = domain.filter((v) => v <= slack);\n        pruned += domain.length - filtered.length;\n        domains[key] = filtered;\n        if (!domains[key].length) {\n          return { domains, pruned, conflict: `Region ${regionId} exhausted for ${key}` };\n        }\n      });\n    } else if (constraint.type === 'op') {\n      if (constraint.op === '=' && (constraint.value < minPossible || constraint.value > maxPossible)) {\n        return { domains, pruned, conflict: `Region ${regionId} cannot reach ${constraint.value}` };\n      }\n    }\n  }\n  return { domains, pruned };\n}\n",
        "last_modified": "2025-12-22T03:10:02.265821"
      },
      "task_intent": {
        "title": "004-add-cross-stage-confidence-warnings-to-ui",
        "description": "Display the confidence hints generated by generateConfidenceHints() in the mobile app's extraction results screen. The backend already computes these hints but the UI only shows the overall confidence percentage.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2025-12-22T03:10:01.213518",
  "last_updated": "2025-12-22T03:10:01.304989"
}