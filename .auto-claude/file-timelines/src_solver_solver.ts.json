{
  "file_path": "src/solver/solver.ts",
  "main_branch_history": [],
  "task_views": {
    "004-add-cross-stage-confidence-warnings-to-ui": {
      "task_id": "004-add-cross-stage-confidence-warnings-to-ui",
      "branch_point": {
        "commit_hash": "faf3f69f9b2794c6a85ffd2581461d3d68bdf8ef",
        "content": "",
        "timestamp": "2025-12-22T03:09:58.791154"
      },
      "worktree_state": {
        "content": "import { normalizePuzzle, NormalizedPuzzle } from '../model/normalize';\nimport { PuzzleSpec, SolveResult, SolverConfig, SolverProgress, SolutionGrid, SolverStats } from '../model/types';\nimport { selectNextVariable } from './heuristics';\nimport { cloneDomains, propagateRegionBounds } from './propagate';\nimport { formatConflict } from './explain';\nimport { DomainMap } from './types';\nimport { validateSolution } from '../validator/validateSolution';\nimport { validateSpec } from '../validator/validateSpec';\n\nfunction initialDomains(puzzle: PuzzleSpec): DomainMap {\n  const domain = Array.from({ length: (puzzle.maxPip ?? 6) + 1 }).map((_, i) => i);\n  const map: DomainMap = {};\n  for (let r = 0; r < puzzle.rows; r++) {\n    for (let c = 0; c < puzzle.cols; c++) {\n      map[`${r},${c}`] = [...domain];\n    }\n  }\n  return map;\n}\n\nfunction sleep(): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, 0));\n}\n\nfunction buildDominoes(puzzle: NormalizedPuzzle, grid: number[][]): { dominoes: SolutionGrid['dominoes']; conflict?: string } {\n  const used: Record<string, boolean> = {};\n  const dominoes: SolutionGrid['dominoes'] = [];\n  for (let r = 0; r < puzzle.rows; r++) {\n    for (let c = 0; c < puzzle.cols; c++) {\n      const key = `${r},${c}`;\n      if (used[key]) continue;\n      const neighbors = puzzle.adjacency[r][c];\n      const neighbor = neighbors.find(([nr, nc]) => !used[`${nr},${nc}`]);\n      if (!neighbor) {\n        return { dominoes, conflict: `Cell ${key} has no free neighbor for domino coverage` };\n      }\n      const [nr, nc] = neighbor;\n      used[key] = true;\n      used[`${nr},${nc}`] = true;\n      const values: [number, number] = [grid[r][c], grid[nr][nc]];\n      const pairId = values[0] <= values[1] ? `${values[0]}-${values[1]}` : `${values[1]}-${values[0]}`;\n      const count = dominoes.filter((d) => d.id === pairId).length;\n      const maxAllowed = puzzle.allowDuplicates ? Infinity : 1;\n      if (count >= maxAllowed) {\n        return { dominoes, conflict: `Domino ${pairId} exhausted` };\n      }\n      dominoes.push({ id: pairId, cells: [[r, c], [nr, nc]], values });\n    }\n  }\n  return { dominoes };\n}\n\nasync function search(\n  puzzle: NormalizedPuzzle,\n  assignment: Map<string, number>,\n  domains: DomainMap,\n  stats: SolverStats,\n  config: SolverConfig,\n  onProgress: (p: SolverProgress) => void,\n  tickCounter: { value: number },\n): Promise<{ solution?: SolutionGrid; conflict?: string }> {\n  if (assignment.size === puzzle.rows * puzzle.cols) {\n    const grid: number[][] = Array.from({ length: puzzle.rows }, () => Array(puzzle.cols).fill(0));\n    assignment.forEach((value, key) => {\n      const [r, c] = key.split(',').map(Number);\n      grid[r][c] = value;\n    });\n    const { dominoes, conflict } = buildDominoes(puzzle, grid);\n    if (conflict) {\n      return { conflict };\n    }\n    return { solution: { gridPips: grid, dominoes } };\n  }\n\n  const variable = selectNextVariable(puzzle, domains, assignment);\n  if (!variable) return { conflict: 'No variable found' };\n  const key = `${variable.r},${variable.c}`;\n  const domain = [...domains[key]];\n  for (const value of domain) {\n    stats.nodes += 1;\n    assignment.set(key, value);\n    const clonedDomains = cloneDomains(domains);\n    clonedDomains[key] = [value];\n    const result = propagateRegionBounds(puzzle, clonedDomains, assignment);\n    stats.prunes += result.pruned;\n    if (result.conflict) {\n      stats.backtracks += 1;\n      assignment.delete(key);\n      continue;\n    }\n    tickCounter.value += 1;\n    if (tickCounter.value % config.progressInterval === 0) {\n      onProgress({ nodes: stats.nodes, backtracks: stats.backtracks });\n      await sleep();\n    }\n    const deeper = await search(puzzle, assignment, result.domains, stats, config, onProgress, tickCounter);\n    if (deeper.solution) return deeper;\n    assignment.delete(key);\n    stats.backtracks += 1;\n  }\n  return { conflict: 'Exhausted domain' };\n}\n\nexport async function solvePuzzle(\n  puzzle: PuzzleSpec,\n  config: SolverConfig,\n  onProgress: (p: SolverProgress) => void,\n): Promise<SolveResult> {\n  const specReport = validateSpec(puzzle);\n  if (!specReport.ok) {\n    return {\n      status: 'unsat',\n      stats: { nodes: 0, backtracks: 0, prunes: 0, elapsedMs: 0 },\n      explanation: 'Specification invalid',\n      validationReport: specReport,\n    };\n  }\n  const normalized = normalizePuzzle(puzzle);\n  const domains = initialDomains(puzzle);\n  const assignment = new Map<string, number>();\n  const stats: SolverStats = { nodes: 0, backtracks: 0, prunes: 0, elapsedMs: 0 };\n  const start = Date.now();\n  const tickCounter = { value: 0 };\n  const result = await search(normalized, assignment, domains, stats, config, onProgress, tickCounter);\n  stats.elapsedMs = Date.now() - start;\n  if (result.solution) {\n    const validationReport = validateSolution(puzzle, result.solution);\n    return { status: 'solved', solution: result.solution, stats, validationReport };\n  }\n  return {\n    status: 'unsat',\n    explanation: formatConflict(result.conflict ?? 'Unknown'),\n    stats,\n    validationReport: { ok: false, issues: [{ level: 'error', message: result.conflict ?? 'Unknown conflict' }] },\n  };\n}\n",
        "last_modified": "2025-12-22T03:10:02.268305"
      },
      "task_intent": {
        "title": "004-add-cross-stage-confidence-warnings-to-ui",
        "description": "Display the confidence hints generated by generateConfidenceHints() in the mobile app's extraction results screen. The backend already computes these hints but the UI only shows the overall confidence percentage.",
        "from_plan": true
      },
      "commits_behind_main": 0,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2025-12-22T03:10:01.311456",
  "last_updated": "2025-12-22T03:10:01.412331"
}